# AINO-app 产品核心架构设计文档

## 📋 概述

本文档描述了 AINO-app 的产品核心架构设计，体现了"卡片是内容承载，组件专注于功能，主次关系明确"的设计哲学。这个架构确保了系统的清晰性、可维护性和扩展性。

## 🎯 核心设计哲学

### 1. 主次关系原则
- **主要**：调用方控制整体结构和容器
- **次要**：组件专注于自己的功能
- **层次清晰**：卡片 → 数据组件 → 具体功能

### 2. 职责分工原则
- **卡片容器**：负责布局、样式和整体结构
- **数据组件**：专注于数据展示逻辑
- **调用方**：决定整体结构和主次关系

### 3. 统一底层配置原则
- 所有组件通过统一的设计令牌系统获取配置
- 配置变更自动影响所有相关组件
- 保持系统的一致性和可预测性

## 🏗️ 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                    产品核心架构设计                              │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   颜色配置      │    │     字体        │    │   卡片配置      │
│ Color Config    │    │   Font Config   │    │ Card Config     │
└─────────┬───────┘    └─────────┬───────┘    └─────────┬───────┘
          │                      │                      │
          └──────────────────────┼──────────────────────┘
                                 │
                    ┌─────────────▼─────────────┐
                    │    统一底层配置            │
                    │ Unified Bottom-Layer     │
                    │    Configuration         │
                    └─────────────┬─────────────┘
                                  │
                    ┌─────────────▼─────────────┐
                    │  配置影响的所有组件        │
                    │ Components Influenced     │
                    │   by Configuration        │
                    └─────────────┬─────────────┘
                                  │
        ┌─────────────────────────┼─────────────────────────┐
        │                         │                         │
┌───────▼────────┐    ┌───────────▼──────────┐    ┌─────────▼─────────┐
│  基础组件      │    │    基础导航          │    │    数据图表      │
│ Basic Comp.    │    │ Basic Navigation    │    │ Data Charts      │
└───────┬────────┘    └──────────┬───────────┘    └─────────┬─────────┘
        │                        │                          │
        └────────────────────────┼──────────────────────────┘
                                 │
                    ┌─────────────▼─────────────┐
                    │        卡片 (Card)        │
                    │   内容承载的核心容器      │
                    │  Core Container for      │
                    │  Content Display         │
                    └─────────────┬─────────────┘
                                  │
                    ┌─────────────▼─────────────┐
                    │      展示内容            │
                    │   Display Content        │
                    └───────────────────────────┘
```

## 🔧 架构实现细节

### 1. 统一底层配置系统

#### 设计令牌管理
```typescript
// 统一的设计令牌接口
interface DesignTokens {
  colors: ColorTokens
  typography: TypographyTokens
  spacing: SpacingTokens
  radius: RadiusTokens
  shadows: ShadowTokens
  borders: BorderTokens
}

// 字体大小配置
interface FontSizeConfig {
  preset: FontSizePreset  // 'small' | 'normal' | 'large'
  scale: number           // 缩放比例
  sizes: FontSize         // 具体字体大小值
}
```

#### 配置应用机制
```typescript
// CSS变量自动应用
const applyFontSizesToDOM = useCallback((fontSizes: Record<string, string>) => {
  Object.entries(fontSizes).forEach(([key, value]) => {
    document.documentElement.style.setProperty(`--font-size-${key}`, value)
  })
}, [])
```

### 2. 拖拽功能架构规则

#### 拖拽卡片架构原则
```typescript
// ✅ 正确：遵循"卡片是内容承载"原则
<DraggableCard id="chart-1" layout={{ x: 0, y: 0, w: 6, h: 4 }}>
  <SimpleBarChart data={chartData} />
</DraggableCard>

// ❌ 错误：组件自带卡片容器
<SimpleBarChart data={chartData} cardContainer={true} />
```

#### 拖拽功能职责分工
- **DraggableCard**：负责拖拽、缩放、位置管理
- **AppCard**：负责卡片样式、主题、容器
- **数据组件**：专注于数据展示逻辑

#### 拖拽状态管理
```typescript
// 使用统一的卡片布局管理Hook
const {
  cards,
  addCard,
  moveCard,
  resizeCard,
  scaleCard,
  validateLayout
} = useCardLayoutManager()
```

### 3. 组件架构规范

#### 数据展示组件规范
```typescript
// ✅ 正确：组件专注于功能
export function SimpleBarChart({ data, className }) {
  return (
    <div className={className}>
      <h3 className="text-lg font-semibold mb-4">数据图表</h3>
      {/* 图表内容 */}
    </div>
  )
}

// ❌ 错误：组件包含容器逻辑
export function SimpleBarChart({ data }) {
  return (
    <div className="card-container p-6 bg-white rounded-lg shadow">
      {/* 不应该包含卡片容器 */}
    </div>
  )
}
```

#### 调用方规范
```typescript
// ✅ 正确：调用方提供容器
<AppCard className="p-6">
  <SimpleBarChart data={chartData} />
</AppCard>

// ✅ 正确：使用拖拽卡片
<DraggableCard id="chart-1" layout={{ x: 0, y: 0, w: 6, h: 4 }}>
  <SimpleBarChart data={chartData} />
</DraggableCard>
```

## 🚀 拖拽功能架构实现

### 1. 拖拽卡片组件 (DraggableCard)

```typescript
// 核心特性
interface DraggableCardProps {
  id: string
  children: React.ReactNode
  layout: { x: number; y: number; w: number; h: number; scale?: number }
  onResize?: (w: number, h: number) => void
  onScale?: (scale: number) => void
  onRemove?: () => void
}

// 架构原则实现
export function DraggableCard({ id, children, layout, ...props }) {
  return (
    <div className="draggable-container">
      {/* 卡片容器 - 遵循"卡片是内容承载"原则 */}
      <AppCard className="w-full h-full">
        {/* 内容区域 - 组件专注于功能 */}
        <div className="content-area">
          {children}
        </div>
        
        {/* 拖拽控制 - 保持现有功能 */}
        <ResizeHandle direction="se" onResize={props.onResize} />
        <ResizeHandle direction="e" onResize={props.onResize} />
        <ResizeHandle direction="s" onResize={props.onResize} />
      </AppCard>
    </div>
  )
}
```

### 2. 卡片布局管理Hook (useCardLayoutManager)

```typescript
// 统一管理所有拖拽相关状态
export function useCardLayoutManager() {
  const [cards, setCards] = useState<CardLayoutConfig[]>([])
  const [layoutMode, setLayoutMode] = useState<'grid' | 'flex' | 'absolute'>('grid')
  
  // 保持所有现有功能
  const addCard = useCallback((config) => { /* 实现 */ }, [])
  const moveCard = useCallback((id, position) => { /* 实现 */ }, [])
  const resizeCard = useCallback((id, size) => { /* 实现 */ }, [])
  const scaleCard = useCallback((id, scale) => { /* 实现 */ }, [])
  
  // 架构验证
  const validateLayout = useCallback(() => {
    return validateCardLayout(cards)
  }, [cards])
  
  return { cards, addCard, moveCard, resizeCard, scaleCard, validateLayout }
}
```

### 3. 架构验证系统

```typescript
// 实时验证组件是否符合架构原则
export function useArchitectureValidator(componentName: string, props: any) {
  const [isValid, setIsValid] = useState(true)
  const [violations, setViolations] = useState<string[]>([])
  
  useEffect(() => {
    const validation = validateCardLayout(componentName, props)
    setIsValid(validation.isValid)
    setViolations(validation.violations)
    
    // 开发环境下输出警告
    if (!validation.isValid) {
      console.warn(`架构验证失败 - ${componentName}:`, validation.violations)
    }
  }, [componentName, props])
  
  return { isValid, violations }
}
```

## 📋 开发约束

### 1. 卡片架构约束
- **禁止**：组件自带卡片容器
- **要求**：组件专注于数据展示功能
- **原则**：卡片是内容承载，组件是功能提供者

### 2. 拖拽功能约束
- **保持**：所有现有拖拽、缩放、调整大小功能
- **优化**：架构规则，不破坏功能
- **验证**：实时检查是否符合架构原则

### 3. 组件设计约束
- **单一职责**：每个组件只负责一个核心功能
- **接受控制**：组件必须接受className、style等外部控制
- **无布局逻辑**：组件不包含布局相关的逻辑

## 🎯 架构优势

### 1. 清晰的主次关系
- 卡片容器控制整体结构和样式
- 数据组件专注于功能实现
- 拖拽系统管理位置和尺寸

### 2. 高度的可维护性
- 职责分离明确
- 代码结构清晰
- 易于扩展和修改

### 3. 统一的配置管理
- 所有组件通过统一系统获取配置
- 配置变更自动影响相关组件
- 保持系统一致性

## 🔮 未来演进

### 1. 拖拽布局系统
- 支持更复杂的布局模式
- 实现响应式拖拽
- 添加布局模板功能

### 2. 组件市场
- 标准化的组件接口
- 第三方组件集成
- 组件版本管理

### 3. 智能布局
- AI辅助布局建议
- 自动布局优化
- 用户行为学习

## 📚 使用指南

### 1. 创建新组件
```typescript
// 1. 专注于功能，不包含容器
export function MyComponent({ data, className }) {
  return (
    <div className={className}>
      {/* 只包含功能逻辑 */}
    </div>
  )
}

// 2. 在调用方提供容器
<AppCard className="p-6">
  <MyComponent data={myData} />
</AppCard>

// 3. 或使用拖拽卡片
<DraggableCard id="my-component" layout={{ x: 0, y: 0, w: 4, h: 3 }}>
  <MyComponent data={myData} />
</DraggableCard>
```

### 2. 使用拖拽功能
```typescript
// 1. 使用统一的布局管理Hook
const layoutManager = useCardLayoutManager()

// 2. 添加卡片
layoutManager.addCard({
  type: 'chart',
  content: <SimpleBarChart data={data} />,
  layout: { x: 0, y: 0, w: 6, h: 4 }
})

// 3. 验证架构
const validation = layoutManager.validateLayout()
if (!validation.isValid) {
  console.warn('架构验证失败:', validation.violations)
}
```

### 3. 架构验证
```typescript
// 在组件中使用验证器
function MyPage() {
  const { isValid, violations } = useArchitectureValidator('MyPage', {})
  
  return (
    <div>
      {/* 页面内容 */}
      
      {/* 显示架构状态 */}
      {!isValid && (
        <div className="architecture-warning">
          架构问题: {violations.join(', ')}
        </div>
      )}
    </div>
  )
}
```

---

**总结**：这个架构设计确保了"卡片是内容承载，组件专注于功能，主次关系明确"的核心原则，同时保持了所有现有的拖拽功能。通过统一的约束系统和验证机制，开发者可以轻松创建符合架构原则的组件，而不会破坏现有的功能。
