# 卡片系统与模块对接方案

## 📋 概述

本文档详细描述了 AINO-app 卡片系统与 AINO 后端模块系统的对接方案，包括如何将动态模块数据通过卡片系统展示，以及如何实现列表配置、详情页绑定等功能。

### ✅ 核心目标

1. **模块数据卡片化展示**：将后端模块数据通过卡片系统统一展示
2. **动态列表配置**：支持用户配置不同模块的列表展示方式
3. **详情页绑定**：支持卡片跳转到对应的详情页面
4. **统一数据接口**：建立卡片系统与模块系统的数据桥梁

## 🏗️ 系统架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    AINO 卡片-模块对接架构 (优化版)              │
├─────────────────────────────────────────────────────────────┤
│  前端卡片系统 (AINO-app)                                    │
│  ├── 卡片容器 (CardContainer)                               │
│  ├── 卡片契约 (CardDefinition)                              │
│  ├── 适配器配置 (AdapterConfig)                             │
│  ├── 动作执行器 (ActionRunner)                              │
│  └── 样式绑定层 (StyleConfig + Bindings)                    │
├─────────────────────────────────────────────────────────────┤
│  Manifest 契约层                                             │
│  ├── 模块契约 (ModuleManifest)                              │
│  ├── 视图配置 (ViewDefinition)                              │
│  ├── 权限策略 (PolicyDefinition)                            │
│  └── 索引提示 (IndexHints)                                  │
├─────────────────────────────────────────────────────────────┤
│  统一查询协议层                                              │
│  ├── 查询 DSL (FilterExpression)                            │
│  ├── 字段选择 (Select)                                      │
│  ├── 关联包含 (Include)                                     │
│  ├── 排序分页 (Sort + PageToken)                            │
│  └── 权限裁剪 (Security Filtering)                          │
├─────────────────────────────────────────────────────────────┤
│  后端模块系统 (AINO-server)                                 │
│  ├── Manifest 服务 (ManifestService)                        │
│  ├── 统一查询引擎 (QueryEngine)                             │
│  ├── 权限引擎 (PermissionEngine)                            │
│  ├── 索引管理器 (IndexManager)                              │
│  └── 事件总线 (EventBus)                                    │
├─────────────────────────────────────────────────────────────┤
│  数据库层                                                    │
│  ├── 模块表 (dir_*)                                         │
│  ├── 字段定义表 (field_defs)                                │
│  ├── 关联关系表 (relation_records)                          │
│  ├── 视图配置表 (view_configs)                              │
│  └── 权限策略表 (policy_configs)                            │
└─────────────────────────────────────────────────────────────┘
```

### 核心设计理念

1. **Manifest 契约驱动**：基于统一的 Manifest 契约自动生成卡片配置
2. **配置化绑定**：通过 AdapterConfig 绑定模块与卡片类型
3. **动态渲染**：根据字段类型和视图配置动态渲染不同的卡片组件
4. **权限集成**：集成字段级权限系统，控制卡片显示和操作
5. **性能优化**：通过索引提示和物化配置实现声明式性能优化

## 🎯 卡片系统现状分析

### 当前卡片系统能力

#### ✅ 已具备的能力

1. **卡片注册系统**
```typescript
// 当前卡片注册方式
CardRegistry.register({
  name: "learning-plan-summary",
  displayName: "学习计划摘要",
  category: "教育",
  type: "summary",
  component: LearningPlanSummaryCard,
  businessFlow: "个性定制学习计划摘要，显示学习时长、目标和评估功能",
  developer: {
    name: "AI Education System",
    version: "1.0.0",
    description: "个性定制学习计划摘要卡片"
  }
})
```

2. **卡片工厂模式**
```typescript
// 统一的卡片创建和管理
export function CardFactory({
  id,
  type,
  cardName,
  data,
  onAction,
  children,
  disableConstraints = false,
}: CardFactoryProps) {
  // 统一的卡片约束和能力
}
```

3. **拖拽和主题系统**
```typescript
// 支持拖拽和主题配置
const cardConstraints = {
  isDraggable: !disableConstraints,
  showSettings: !disableConstraints,
  disableLocalTheme: disableConstraints,
}
```

4. **业务卡片类型**
- 教育类：学习计划、课程模块、学习成果
- 招聘类：工作年限分析、就业趋势、职位发布
- 内容类：媒体编辑器、文章编辑器
- 数据类：图表展示、统计分析

#### 🚧 需要增强的能力

1. **动态数据绑定**：当前卡片使用静态数据，需要支持动态模块数据
2. **字段映射系统**：需要建立模块字段与卡片字段的映射关系
3. **列表配置系统**：需要支持用户配置列表展示方式
4. **详情页集成**：需要支持卡片跳转到详情页面

## 🔧 模块对接方案设计

### 1. Manifest 契约系统

#### 1.1 模块 Manifest 定义
```typescript
// 模块 Manifest 接口
interface ModuleManifest {
  moduleKey: string
  schemaVersion: string
  fields: FieldDefinition[]
  relations: RelationDefinition[]
  views: ViewDefinition[]
  policies: PolicyDefinition
  indexHints: IndexHint[]
  materialize: MaterializeConfig[]
  changelog: ChangelogEntry[]
}

// 字段定义
interface FieldDefinition {
  key: string
  label: string
  type: string
  required: boolean
  options?: any[]
  validators?: ValidatorConfig[]
  ui?: UIConfig
  index?: boolean
  materialize?: boolean
}

// 视图定义
interface ViewDefinition {
  key: string
  version: string
  layout: "grid" | "table" | "kanban" | "list"
  columns: ColumnDefinition[]
  sort: SortExpression[]
  filters: FilterDefinition[]
  cardTemplate?: string
  pagination: PaginationConfig
}

// 权限策略定义
interface PolicyDefinition {
  fieldLevel: Record<string, {
    read: string
    write: string
  }>
  recordLevel: {
    read: string
    write: string
  }
}
```

#### 1.2 Manifest 服务
```typescript
// Manifest 服务
export class ManifestService {
  // 获取模块 Manifest
  static async getManifest(appId: string, moduleKey: string): Promise<ModuleManifest> {
    const response = await fetch(`/api/apps/${appId}/modules/${moduleKey}/manifest`)
    return response.json()
  }

  // 检查 Schema 版本
  static checkSchemaVersion(response: Response): string | null {
    return response.headers.get('X-Schema-Version')
  }

  // 缓存管理
  static cacheManifest(moduleKey: string, manifest: ModuleManifest): void {
    localStorage.setItem(`manifest_${moduleKey}`, JSON.stringify(manifest))
  }

  static getCachedManifest(moduleKey: string): ModuleManifest | null {
    const cached = localStorage.getItem(`manifest_${moduleKey}`)
    return cached ? JSON.parse(cached) : null
  }
}
```

### 2. 统一查询协议

#### 2.1 查询 DSL 定义
```typescript
// 查询请求接口
interface QueryRequest {
  moduleKey: string
  filter?: FilterExpression
  select?: string[]
  include?: IncludeExpression[]
  sort?: SortExpression[]
  pageToken?: string
  limit?: number
}

// 过滤表达式
type FilterExpression = 
  | { and: FilterExpression[] }
  | { or: FilterExpression[] }
  | { path: string; op: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte' | 'like' | 'in' | 'exists'; value: any }

// 关联包含表达式
interface IncludeExpression {
  relation: string
  fields?: string[]
  depth?: number
  limit?: number
}

// 排序表达式
type SortExpression = [string, 'asc' | 'desc']
```

#### 2.2 查询服务
```typescript
// 统一查询服务
export class QueryService {
  // 执行查询
  static async query(request: QueryRequest): Promise<QueryResponse> {
    const params = new URLSearchParams()
    params.set('moduleKey', request.moduleKey)
    
    if (request.filter) {
      params.set('filter', JSON.stringify(request.filter))
    }
    if (request.select) {
      params.set('select', JSON.stringify(request.select))
    }
    if (request.include) {
      params.set('include', JSON.stringify(request.include))
    }
    if (request.sort) {
      params.set('sort', JSON.stringify(request.sort))
    }
    if (request.pageToken) {
      params.set('pageToken', request.pageToken)
    }
    if (request.limit) {
      params.set('limit', request.limit.toString())
    }

    const response = await fetch(`/api/records?${params}`)
    return response.json()
  }

  // 构建过滤条件
  static buildFilter(conditions: Record<string, any>): FilterExpression {
    const expressions = Object.entries(conditions).map(([path, value]) => ({
      path,
      op: 'eq' as const,
      value
    }))
    
    return expressions.length === 1 ? expressions[0] : { and: expressions }
  }
}
```

### 3. 卡片容器系统

#### 3.1 卡片容器组件
```typescript
// 卡片容器组件
interface CardContainerProps {
  moduleKey: string
  viewKey?: string
  adapterConfig: AdapterConfig
  onAction?: (action: string, data: any) => void
}

export function CardContainer({ 
  moduleKey, 
  viewKey = 'default', 
  adapterConfig, 
  onAction 
}: CardContainerProps) {
  const [manifest, setManifest] = useState<ModuleManifest | null>(null)
  const [data, setData] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    loadManifest()
  }, [moduleKey])

  useEffect(() => {
    if (manifest) {
      loadData()
    }
  }, [manifest, viewKey])

  const loadManifest = async () => {
    try {
      // 先尝试从缓存获取
      let manifest = ManifestService.getCachedManifest(moduleKey)
      
      if (!manifest) {
        manifest = await ManifestService.getManifest('current-app', moduleKey)
        ManifestService.cacheManifest(moduleKey, manifest)
      }
      
      setManifest(manifest)
    } catch (error) {
      setError(`加载 Manifest 失败: ${error.message}`)
    }
  }

  const loadData = async () => {
    if (!manifest) return

    setLoading(true)
    try {
      const view = manifest.views.find(v => v.key === viewKey) || manifest.views[0]
      
      const queryRequest: QueryRequest = {
        moduleKey,
        select: view.columns.map(c => c.field),
        sort: view.sort,
        limit: view.pagination.pageSize
      }

      const response = await QueryService.query(queryRequest)
      setData(response.data || [])
    } catch (error) {
      setError(`加载数据失败: ${error.message}`)
    } finally {
      setLoading(false)
    }
  }

  if (loading) {
    return <CardSkeleton />
  }

  if (error) {
    return <CardError message={error} />
  }

  if (!manifest) {
    return <CardEmpty message="Manifest 未找到" />
  }

  const view = manifest.views.find(v => v.key === viewKey) || manifest.views[0]

  return (
    <div className="card-container">
      {view.layout === 'grid' ? (
        <GridLayout 
          data={data}
          manifest={manifest}
          view={view}
          adapterConfig={adapterConfig}
          onAction={onAction}
        />
      ) : (
        <TableLayout 
          data={data}
          manifest={manifest}
          view={view}
          adapterConfig={adapterConfig}
          onAction={onAction}
        />
      )}
    </div>
  )
}
```

#### 3.2 卡片契约定义
```typescript
// 卡片契约定义
interface CardDefinition {
  key: string
  version: string
  dataContract: {
    required: string[]
    optional: string[]
  }
  slots: SlotDefinition[]
  actions: ActionDefinition[]
}

// 槽位定义
interface SlotDefinition {
  name: string
  type: 'header' | 'content' | 'footer' | 'actions'
  required: boolean
  component?: string
}

// 动作定义
interface ActionDefinition {
  key: string
  label: string
  kind: 'server' | 'client' | 'link'
  endpoint?: string
  params?: Record<string, any>
  confirm?: string
  successToast?: string
  failureToast?: string
}
```

#### 3.3 适配器配置
```typescript
// 适配器配置
interface AdapterConfig {
  moduleKey: string
  fieldMap: Record<string, string>
  relations: string[]
  compute: Record<string, string>
  styleConfig?: StyleConfig
}

// 样式配置
interface StyleConfig {
  theme: 'default' | 'dark' | 'minimal'
  tokens: Record<string, string>
  bindings: Record<string, string>
}
```

### 4. 动作执行器

#### 4.1 动作执行器组件
```typescript
// 动作执行器
export class ActionRunner {
  // 执行动作
  static async executeAction(
    action: ActionDefinition, 
    data: any, 
    context: ActionContext
  ): Promise<ActionResult> {
    try {
      switch (action.kind) {
        case 'server':
          return await this.executeServerAction(action, data, context)
        case 'client':
          return await this.executeClientAction(action, data, context)
        case 'link':
          return await this.executeLinkAction(action, data, context)
        default:
          throw new Error(`未知的动作类型: ${action.kind}`)
      }
    } catch (error) {
      return {
        success: false,
        error: error.message,
        toast: action.failureToast || '操作失败'
      }
    }
  }

  // 执行服务端动作
  private static async executeServerAction(
    action: ActionDefinition, 
    data: any, 
    context: ActionContext
  ): Promise<ActionResult> {
    const response = await fetch(action.endpoint!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...action.params,
        data
      })
    })

    if (!response.ok) {
      throw new Error(`服务端动作执行失败: ${response.statusText}`)
    }

    const result = await response.json()
    return {
      success: true,
      data: result,
      toast: action.successToast || '操作成功'
    }
  }

  // 执行客户端动作
  private static async executeClientAction(
    action: ActionDefinition, 
    data: any, 
    context: ActionContext
  ): Promise<ActionResult> {
    // 执行客户端逻辑
    const result = await context.clientActions[action.key]?.(data)
    return {
      success: true,
      data: result,
      toast: action.successToast || '操作成功'
    }
  }

  // 执行链接动作
  private static async executeLinkAction(
    action: ActionDefinition, 
    data: any, 
    context: ActionContext
  ): Promise<ActionResult> {
    const url = this.interpolateUrl(action.endpoint!, data)
    window.open(url, '_blank')
    return {
      success: true,
      toast: action.successToast || '已打开链接'
    }
  }

  // URL 插值
  private static interpolateUrl(template: string, data: any): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return data[key] || match
    })
  }
}
```

### 5. 模块卡片适配器

#### 1.1 核心适配器设计
```typescript
// 模块卡片适配器
export class ModuleCardAdapter {
  // 根据模块 Schema 生成卡片配置
  static generateCardConfig(moduleSchema: ModuleSchema): CardConfig {
    return {
      name: `module-${moduleSchema.key}`,
      displayName: moduleSchema.title,
      category: moduleSchema.category || "模块",
      type: this.determineCardType(moduleSchema),
      component: this.createDynamicComponent(moduleSchema),
      businessFlow: `动态模块卡片：${moduleSchema.description}`,
      developer: {
        name: "AINO Module System",
        version: "1.0.0",
        description: `基于模块 ${moduleSchema.key} 的动态卡片`
      },
      // 模块特有配置
      moduleConfig: {
        moduleKey: moduleSchema.key,
        fields: moduleSchema.fields,
        permissions: moduleSchema.permissions,
        relations: moduleSchema.relations
      }
    }
  }

  // 根据字段类型确定卡片类型
  private static determineCardType(schema: ModuleSchema): CardType {
    const fieldTypes = schema.fields.map(f => f.type)
    
    if (fieldTypes.includes('chart') || fieldTypes.includes('statistics')) {
      return 'chart'
    }
    if (fieldTypes.includes('list') || fieldTypes.includes('table')) {
      return 'list'
    }
    if (fieldTypes.includes('form') || fieldTypes.includes('input')) {
      return 'form'
    }
    return 'summary'
  }

  // 创建动态组件
  private static createDynamicComponent(schema: ModuleSchema): React.ComponentType {
    return function DynamicModuleCard({ data, onAction }: BusinessCardProps) {
      return (
        <ModuleCardRenderer 
          schema={schema}
          data={data}
          onAction={onAction}
        />
      )
    }
  }
}
```

#### 1.2 动态模块卡片渲染器
```typescript
// 动态模块卡片渲染器
interface ModuleCardRendererProps {
  schema: ModuleSchema
  data: any
  onAction?: (action: string, data: any) => void
}

export function ModuleCardRenderer({ schema, data, onAction }: ModuleCardRendererProps) {
  const { fields } = schema
  
  return (
    <AppCard className="p-6">
      <div className="space-y-4">
        {/* 卡片标题 */}
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold">{schema.title}</h3>
          <Badge variant="outline">{schema.key}</Badge>
        </div>

        {/* 动态字段渲染 */}
        <div className="space-y-3">
          {fields.map(field => (
            <FieldRenderer
              key={field.key}
              field={field}
              value={data?.[field.key]}
              onAction={onAction}
            />
          ))}
        </div>

        {/* 操作按钮 */}
        <div className="flex gap-2 pt-2">
          <Button 
            size="sm" 
            onClick={() => onAction?.('view', data)}
          >
            查看详情
          </Button>
          <Button 
            size="sm" 
            variant="outline"
            onClick={() => onAction?.('edit', data)}
          >
            编辑
          </Button>
        </div>
      </div>
    </AppCard>
  )
}
```

### 2. 字段渲染系统

#### 2.1 字段渲染器
```typescript
// 字段渲染器
interface FieldRendererProps {
  field: FieldDef
  value: any
  onAction?: (action: string, data: any) => void
}

export function FieldRenderer({ field, value, onAction }: FieldRendererProps) {
  const renderField = () => {
    switch (field.type) {
      case 'text':
        return <TextField field={field} value={value} />
      case 'number':
        return <NumberField field={field} value={value} />
      case 'select':
        return <SelectField field={field} value={value} />
      case 'date':
        return <DateField field={field} value={value} />
      case 'relation':
        return <RelationField field={field} value={value} onAction={onAction} />
      case 'chart':
        return <ChartField field={field} value={value} />
      case 'list':
        return <ListField field={field} value={value} onAction={onAction} />
      default:
        return <DefaultField field={field} value={value} />
    }
  }

  return (
    <div className="field-item">
      <label className="text-sm font-medium text-muted-foreground">
        {field.label}
      </label>
      <div className="mt-1">
        {renderField()}
      </div>
    </div>
  )
}
```

#### 2.2 具体字段组件
```typescript
// 文本字段
function TextField({ field, value }: { field: FieldDef; value: any }) {
  return (
    <div className="text-sm">
      {value || <span className="text-muted-foreground">未设置</span>}
    </div>
  )
}

// 关联字段
function RelationField({ field, value, onAction }: FieldRendererProps) {
  const handleClick = () => {
    if (field.relation?.targetModule) {
      onAction?.('navigate', {
        module: field.relation.targetModule,
        id: value
      })
    }
  }

  return (
    <div 
      className="text-sm text-blue-600 cursor-pointer hover:underline"
      onClick={handleClick}
    >
      {value || '未关联'}
    </div>
  )
}

// 图表字段
function ChartField({ field, value }: { field: FieldDef; value: any }) {
  return (
    <div className="h-32 bg-gray-50 rounded-lg flex items-center justify-center">
      <ResponsiveContainer width="100%" height="100%">
        <SimpleBarChart data={value} />
      </ResponsiveContainer>
    </div>
  )
}

// 列表字段
function ListField({ field, value, onAction }: FieldRendererProps) {
  const items = Array.isArray(value) ? value.slice(0, 3) : []
  
  return (
    <div className="space-y-1">
      {items.map((item, index) => (
        <div 
          key={index}
          className="text-sm p-2 bg-gray-50 rounded cursor-pointer hover:bg-gray-100"
          onClick={() => onAction?.('view-item', item)}
        >
          {item.name || item.title || `项目 ${index + 1}`}
        </div>
      ))}
      {value?.length > 3 && (
        <div className="text-xs text-muted-foreground">
          还有 {value.length - 3} 项...
        </div>
      )}
    </div>
  )
}
```

### 3. 列表配置系统

#### 3.1 列表配置接口
```typescript
// 列表配置接口
interface ListConfig {
  id: string
  moduleKey: string
  name: string
  description?: string
  cardType: CardType
  displayFields: string[]  // 要显示的字段
  sortField?: string
  sortOrder?: 'asc' | 'desc'
  filterConfig?: FilterConfig
  pageSize: number
  layout: 'grid' | 'list' | 'table'
  customConfig?: Record<string, any>
}

interface FilterConfig {
  fields: Array<{
    fieldKey: string
    operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'in'
    value: any
  }>
}
```

#### 3.2 列表配置管理器
```typescript
// 列表配置管理器
export class ListConfigManager {
  // 获取模块的列表配置
  static async getListConfigs(moduleKey: string): Promise<ListConfig[]> {
    const response = await fetch(`/api/modules/${moduleKey}/list-configs`)
    return response.json()
  }

  // 创建列表配置
  static async createListConfig(config: Omit<ListConfig, 'id'>): Promise<ListConfig> {
    const response = await fetch('/api/list-configs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    })
    return response.json()
  }

  // 更新列表配置
  static async updateListConfig(id: string, config: Partial<ListConfig>): Promise<ListConfig> {
    const response = await fetch(`/api/list-configs/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    })
    return response.json()
  }

  // 删除列表配置
  static async deleteListConfig(id: string): Promise<void> {
    await fetch(`/api/list-configs/${id}`, { method: 'DELETE' })
  }
}
```

#### 3.3 动态列表渲染器
```typescript
// 动态列表渲染器
interface DynamicListRendererProps {
  moduleKey: string
  listConfigId?: string
  onCardAction?: (action: string, data: any) => void
}

export function DynamicListRenderer({ 
  moduleKey, 
  listConfigId, 
  onCardAction 
}: DynamicListRendererProps) {
  const [listConfig, setListConfig] = useState<ListConfig | null>(null)
  const [data, setData] = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    loadListConfig()
  }, [moduleKey, listConfigId])

  useEffect(() => {
    if (listConfig) {
      loadData()
    }
  }, [listConfig])

  const loadListConfig = async () => {
    try {
      let config: ListConfig
      if (listConfigId) {
        config = await ListConfigManager.getListConfig(listConfigId)
      } else {
        const configs = await ListConfigManager.getListConfigs(moduleKey)
        config = configs[0] || await createDefaultConfig()
      }
      setListConfig(config)
    } catch (error) {
      console.error('加载列表配置失败:', error)
    }
  }

  const loadData = async () => {
    if (!listConfig) return

    setLoading(true)
    try {
      const params = new URLSearchParams({
        moduleKey,
        fields: listConfig.displayFields.join(','),
        pageSize: listConfig.pageSize.toString(),
        ...(listConfig.sortField && { sort: `${listConfig.sortField}:${listConfig.sortOrder}` })
      })

      const response = await fetch(`/api/records?${params}`)
      const result = await response.json()
      setData(result.data || [])
    } catch (error) {
      console.error('加载数据失败:', error)
    } finally {
      setLoading(false)
    }
  }

  const createDefaultConfig = async (): Promise<ListConfig> => {
    // 获取模块 Schema
    const schemaResponse = await fetch(`/api/modules/${moduleKey}/schema`)
    const schema = await schemaResponse.json()

    const defaultConfig: Omit<ListConfig, 'id'> = {
      moduleKey,
      name: `${schema.title} 列表`,
      cardType: 'summary',
      displayFields: schema.fields.slice(0, 5).map((f: FieldDef) => f.key),
      pageSize: 20,
      layout: 'grid'
    }

    return await ListConfigManager.createListConfig(defaultConfig)
  }

  if (loading) {
    return <div className="flex justify-center p-8">加载中...</div>
  }

  if (!listConfig) {
    return <div className="text-center p-8 text-muted-foreground">配置加载失败</div>
  }

  return (
    <div className="space-y-4">
      {/* 列表头部 */}
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">{listConfig.name}</h2>
        <div className="flex gap-2">
          <Button size="sm" variant="outline">
            配置列表
          </Button>
          <Button size="sm">
            添加记录
          </Button>
        </div>
      </div>

      {/* 数据展示 */}
      {listConfig.layout === 'grid' ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {data.map((item) => (
            <ModuleCardRenderer
              key={item.id}
              schema={listConfig.moduleSchema}
              data={item}
              onAction={onCardAction}
            />
          ))}
        </div>
      ) : (
        <div className="space-y-2">
          {data.map((item) => (
            <ModuleCardRenderer
              key={item.id}
              schema={listConfig.moduleSchema}
              data={item}
              onAction={onCardAction}
            />
          ))}
        </div>
      )}
    </div>
  )
}
```

### 4. 详情页集成系统

#### 4.1 详情页路由配置
```typescript
// 详情页路由配置
interface DetailPageConfig {
  id: string
  moduleKey: string
  name: string
  path: string
  component: string
  fields: string[]
  layout: 'form' | 'card' | 'custom'
  permissions?: string[]
}

// 详情页路由管理器
export class DetailPageManager {
  // 获取模块的详情页配置
  static async getDetailPageConfigs(moduleKey: string): Promise<DetailPageConfig[]> {
    const response = await fetch(`/api/modules/${moduleKey}/detail-pages`)
    return response.json()
  }

  // 创建详情页配置
  static async createDetailPageConfig(config: Omit<DetailPageConfig, 'id'>): Promise<DetailPageConfig> {
    const response = await fetch('/api/detail-pages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    })
    return response.json()
  }
}
```

#### 4.2 详情页组件
```typescript
// 详情页组件
interface DetailPageProps {
  moduleKey: string
  recordId: string
  config?: DetailPageConfig
}

export function DetailPage({ moduleKey, recordId, config }: DetailPageProps) {
  const [record, setRecord] = useState<any>(null)
  const [loading, setLoading] = useState(true)
  const [schema, setSchema] = useState<ModuleSchema | null>(null)

  useEffect(() => {
    loadData()
  }, [moduleKey, recordId])

  const loadData = async () => {
    setLoading(true)
    try {
      // 加载记录数据
      const recordResponse = await fetch(`/api/records/${moduleKey}/${recordId}`)
      const recordData = await recordResponse.json()
      setRecord(recordData.data)

      // 加载模块 Schema
      const schemaResponse = await fetch(`/api/modules/${moduleKey}/schema`)
      const schemaData = await schemaResponse.json()
      setSchema(schemaData)
    } catch (error) {
      console.error('加载详情数据失败:', error)
    } finally {
      setLoading(false)
    }
  }

  if (loading) {
    return <div className="flex justify-center p-8">加载中...</div>
  }

  if (!record || !schema) {
    return <div className="text-center p-8 text-muted-foreground">数据加载失败</div>
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* 页面头部 */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">{schema.title} 详情</h1>
          <p className="text-muted-foreground">记录 ID: {recordId}</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline">
            编辑
          </Button>
          <Button variant="outline">
            删除
          </Button>
        </div>
      </div>

      {/* 详情内容 */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* 主要信息 */}
        <div className="lg:col-span-2">
          <AppCard className="p-6">
            <h2 className="text-lg font-semibold mb-4">基本信息</h2>
            <div className="space-y-4">
              {schema.fields.map(field => (
                <FieldRenderer
                  key={field.key}
                  field={field}
                  value={record[field.key]}
                />
              ))}
            </div>
          </AppCard>
        </div>

        {/* 侧边信息 */}
        <div className="space-y-4">
          {/* 关联信息 */}
          {schema.relations && schema.relations.length > 0 && (
            <AppCard className="p-4">
              <h3 className="font-semibold mb-3">关联信息</h3>
              <div className="space-y-2">
                {schema.relations.map(relation => (
                  <div key={relation.key} className="text-sm">
                    <span className="text-muted-foreground">{relation.label}:</span>
                    <div className="mt-1">
                      {record[relation.key] ? (
                        <Button 
                          variant="link" 
                          size="sm"
                          onClick={() => navigateToRelation(relation, record[relation.key])}
                        >
                          {record[relation.key]}
                        </Button>
                      ) : (
                        <span className="text-muted-foreground">未设置</span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </AppCard>
          )}

          {/* 操作历史 */}
          <AppCard className="p-4">
            <h3 className="font-semibold mb-3">操作历史</h3>
            <div className="text-sm text-muted-foreground">
              <div>创建时间: {record.createdAt}</div>
              <div>更新时间: {record.updatedAt}</div>
            </div>
          </AppCard>
        </div>
      </div>
    </div>
  )
}
```

### 5. 数据转换和映射

#### 5.1 模块数据转换器
```typescript
// 模块数据转换器
export class ModuleDataTransformer {
  // 将模块数据转换为卡片数据
  static transformToCardData(moduleData: any, schema: ModuleSchema): any {
    const cardData: any = {
      id: moduleData.id,
      ...moduleData.props
    }

    // 处理关联字段
    schema.fields.forEach(field => {
      if (field.type === 'relation' && moduleData[field.key]) {
        cardData[field.key] = this.transformRelationField(
          moduleData[field.key], 
          field
        )
      }
    })

    return cardData
  }

  // 转换关联字段
  private static transformRelationField(value: any, field: FieldDef): any {
    if (field.relation?.targetModule) {
      return {
        id: value,
        module: field.relation.targetModule,
        displayField: field.relation.displayField || 'name'
      }
    }
    return value
  }

  // 将卡片数据转换为模块数据
  static transformToModuleData(cardData: any, schema: ModuleSchema): any {
    const moduleData: any = {
      props: {}
    }

    schema.fields.forEach(field => {
      if (cardData[field.key] !== undefined) {
        if (field.type === 'relation' && typeof cardData[field.key] === 'object') {
          moduleData.props[field.key] = cardData[field.key].id
        } else {
          moduleData.props[field.key] = cardData[field.key]
        }
      }
    })

    return moduleData
  }
}
```

#### 5.2 字段映射器
```typescript
// 字段映射器
export class FieldMapper {
  // 根据字段类型映射到对应的渲染组件
  static mapFieldToComponent(field: FieldDef): string {
    const typeMapping: Record<string, string> = {
      'text': 'TextField',
      'number': 'NumberField',
      'select': 'SelectField',
      'date': 'DateField',
      'relation': 'RelationField',
      'chart': 'ChartField',
      'list': 'ListField',
      'image': 'ImageField',
      'file': 'FileField'
    }

    return typeMapping[field.type] || 'DefaultField'
  }

  // 根据字段配置生成显示配置
  static generateDisplayConfig(field: FieldDef): DisplayConfig {
    return {
      component: this.mapFieldToComponent(field),
      props: {
        label: field.label,
        required: field.required,
        options: field.options,
        ...field.ui
      }
    }
  }
}
```

## 🎯 实施计划

### ⚙️ 推荐落地顺序（两周冲刺拆解）

#### 第 1-3 天：Manifest 契约 + 统一查询协议
- [ ] **Manifest 服务实现**
  - 实现 `ManifestService` 类
  - 创建 Manifest API 端点
  - 实现 Schema 版本检查机制
  - 添加响应头 `X-Schema-Version`

- [ ] **统一查询协议**
  - 实现 `QueryService` 类
  - 支持 filter/select/include/sort/pageToken
  - 实现查询 DSL 解析器
  - 支持游标分页

- [ ] **基础视图模型**
  - 实现 `list_default` 和 `detail_default` 视图
  - 支持基础的列配置和排序

#### 第 4-7 天：卡片容器 + 权限系统
- [ ] **卡片容器系统**
  - 实现 `<CardContainer/>` 组件
  - 定义 `CardDefinition` 契约
  - 实现 `AdapterConfig` 配置系统
  - 支持网格和表格布局

- [ ] **字段级权限裁剪**
  - 实现 `PolicyDefinition` 权限策略
  - 服务端字段级权限过滤
  - 前端权限状态管理

- [ ] **索引优化**
  - 实现 `IndexHints` 配置
  - 自动创建表达式索引
  - 首批热门字段索引优化

#### 第 8-10 天：动作系统 + 事件总线
- [ ] **统一动作协议**
  - 实现 `ActionRunner` 动作执行器
  - 支持 server/client/link 三种动作类型
  - 实现动作确认和提示机制

- [ ] **事件总线系统**
  - 实现 `EventBus` 事件系统
  - 支持 `schema.updated` 事件
  - 前端热更新机制

- [ ] **生成型 SDK（可选）**
  - 基于 Manifest 生成 TypeScript 类型
  - 自动生成 API SDK
  - 集成到构建流程

#### 第 11-14 天：性能优化 + 样式系统
- [ ] **性能压测与调优**
  - 大规模数据测试
  - 查询性能优化
  - 索引效果验证

- [ ] **视图版本与灰度**
  - 视图版本管理
  - 灰度发布机制
  - 破坏性变更处理

- [ ] **样式配置系统**
  - 实现 `StyleConfig` 配置
  - 支持主题切换
  - 数据绑定表达式

### 🧪 验收用例

#### 用例1：新增字段测试
**场景**：给"职位"模块新增 `priority` 字段（枚举类型）
**步骤**：
1. 更新 Manifest 中的字段定义
2. 更新视图配置，添加新列
3. 前端无需修改代码
**验收**：新字段自动出现在列表和详情页

#### 用例2：权限控制测试
**场景**：将"薪资上限"字段设置为仅管理员可见
**步骤**：
1. 在 Manifest 中配置字段级权限
2. 低权限用户访问数据
**验收**：响应中不包含薪资字段，列表也不显示

#### 用例3：视图切换测试
**场景**：将"职位列表"从表格视图切换到卡片栅格视图
**步骤**：
1. 创建新的视图配置
2. 修改页面中的 `viewKey` 参数
**验收**：页面布局自动切换，无需修改组件代码

#### 用例4：复杂查询测试
**场景**：按"城市+年限"组合筛选职位
**步骤**：
1. 构建复杂的过滤表达式
2. 执行查询请求
**验收**：查询响应时间 < 200ms，结果准确

#### 用例5：破坏性变更测试
**场景**：重命名字段 ID（如 `title` → `jobTitle`）
**步骤**：
1. 在 Manifest 中标记字段为 `deprecated`
2. 添加 `replacementKey` 配置
3. 前端显示迁移提示
**验收**：系统不崩溃，显示友好的迁移提示

### 阶段1：基础对接（优先级：高）

#### 1.1 模块卡片适配器
- [ ] 实现 `ModuleCardAdapter` 类
- [ ] 创建 `ModuleCardRenderer` 组件
- [ ] 实现基础的字段渲染器

#### 1.2 数据接口集成
- [ ] 集成模块 Schema API
- [ ] 集成记录 CRUD API
- [ ] 实现数据转换器

#### 1.3 基础卡片类型
- [ ] 实现文本、数字、选择字段卡片
- [ ] 实现关联字段卡片
- [ ] 实现列表字段卡片

### 阶段2：列表配置系统（优先级：高）

#### 2.1 列表配置管理
- [ ] 实现 `ListConfigManager` 类
- [ ] 创建列表配置 API
- [ ] 实现配置存储

#### 2.2 动态列表渲染
- [ ] 实现 `DynamicListRenderer` 组件
- [ ] 支持网格和列表布局
- [ ] 实现分页和排序

#### 2.3 配置界面
- [ ] 创建列表配置界面
- [ ] 支持字段选择和排序配置
- [ ] 支持筛选条件配置

### 阶段3：详情页集成（优先级：中）

#### 3.1 详情页系统
- [ ] 实现 `DetailPageManager` 类
- [ ] 创建详情页组件
- [ ] 实现路由集成

#### 3.2 详情页配置
- [ ] 支持详情页布局配置
- [ ] 支持字段显示配置
- [ ] 支持关联信息展示

### 阶段4：高级功能（优先级：低）

#### 4.1 权限集成
- [ ] 集成模块权限系统
- [ ] 实现字段级权限控制
- [ ] 支持操作权限控制

#### 4.2 高级字段类型
- [ ] 实现图表字段
- [ ] 实现文件上传字段
- [ ] 实现复杂表单字段

#### 4.3 性能优化
- [ ] 实现数据缓存
- [ ] 优化大量数据渲染
- [ ] 实现虚拟滚动

## 🔧 技术实现细节

### 1. 卡片注册增强

#### 1.1 模块卡片自动注册
```typescript
// 模块卡片自动注册
export class ModuleCardRegistry {
  private static moduleCards = new Map<string, CardConfig>()

  // 注册模块卡片
  static async registerModuleCard(moduleKey: string): Promise<void> {
    try {
      // 获取模块 Schema
      const schema = await this.getModuleSchema(moduleKey)
      
      // 生成卡片配置
      const cardConfig = ModuleCardAdapter.generateCardConfig(schema)
      
      // 注册到卡片系统
      CardRegistry.register(cardConfig)
      
      // 保存到本地注册表
      this.moduleCards.set(moduleKey, cardConfig)
    } catch (error) {
      console.error(`注册模块卡片失败: ${moduleKey}`, error)
    }
  }

  // 获取所有模块卡片
  static getModuleCards(): CardConfig[] {
    return Array.from(this.moduleCards.values())
  }

  // 获取模块 Schema
  private static async getModuleSchema(moduleKey: string): Promise<ModuleSchema> {
    const response = await fetch(`/api/modules/${moduleKey}/schema`)
    if (!response.ok) {
      throw new Error(`获取模块 Schema 失败: ${moduleKey}`)
    }
    return response.json()
  }
}
```

#### 1.2 卡片配置持久化
```typescript
// 卡片配置持久化
export class CardConfigStorage {
  private static STORAGE_KEY = 'aino_card_configs'

  // 保存卡片配置
  static saveCardConfig(moduleKey: string, config: CardConfig): void {
    const configs = this.getCardConfigs()
    configs[moduleKey] = config
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(configs))
  }

  // 获取卡片配置
  static getCardConfig(moduleKey: string): CardConfig | null {
    const configs = this.getCardConfigs()
    return configs[moduleKey] || null
  }

  // 获取所有卡片配置
  static getCardConfigs(): Record<string, CardConfig> {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY)
      return stored ? JSON.parse(stored) : {}
    } catch {
      return {}
    }
  }

  // 删除卡片配置
  static removeCardConfig(moduleKey: string): void {
    const configs = this.getCardConfigs()
    delete configs[moduleKey]
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(configs))
  }
}
```

### 2. 路由集成

#### 2.1 动态路由生成
```typescript
// 动态路由生成
export class DynamicRouteGenerator {
  // 生成模块路由
  static generateModuleRoutes(modules: ModuleSchema[]): RouteConfig[] {
    return modules.map(module => ({
      path: `/modules/${module.key}`,
      component: 'ModuleListPage',
      props: { moduleKey: module.key }
    }))
  }

  // 生成详情页路由
  static generateDetailRoutes(modules: ModuleSchema[]): RouteConfig[] {
    return modules.flatMap(module => [
      {
        path: `/modules/${module.key}/:id`,
        component: 'ModuleDetailPage',
        props: { moduleKey: module.key }
      }
    ])
  }
}
```

#### 2.2 路由配置
```typescript
// 路由配置
const routes = [
  // 模块列表页
  {
    path: '/modules/:moduleKey',
    component: DynamicListRenderer,
    props: { moduleKey: ':moduleKey' }
  },
  // 模块详情页
  {
    path: '/modules/:moduleKey/:id',
    component: DetailPage,
    props: { moduleKey: ':moduleKey', recordId: ':id' }
  },
  // 模块配置页
  {
    path: '/modules/:moduleKey/config',
    component: ModuleConfigPage,
    props: { moduleKey: ':moduleKey' }
  }
]
```

### 3. 状态管理

#### 3.1 模块状态管理
```typescript
// 模块状态管理
interface ModuleState {
  modules: Record<string, ModuleSchema>
  listConfigs: Record<string, ListConfig[]>
  detailConfigs: Record<string, DetailPageConfig[]>
  loading: boolean
  error: string | null
}

export const useModuleStore = create<ModuleState>((set, get) => ({
  modules: {},
  listConfigs: {},
  detailConfigs: {},
  loading: false,
  error: null,

  // 加载模块
  loadModule: async (moduleKey: string) => {
    set({ loading: true, error: null })
    try {
      const schema = await fetchModuleSchema(moduleKey)
      set(state => ({
        modules: { ...state.modules, [moduleKey]: schema }
      }))
    } catch (error) {
      set({ error: error.message })
    } finally {
      set({ loading: false })
    }
  },

  // 加载列表配置
  loadListConfigs: async (moduleKey: string) => {
    try {
      const configs = await ListConfigManager.getListConfigs(moduleKey)
      set(state => ({
        listConfigs: { ...state.listConfigs, [moduleKey]: configs }
      }))
    } catch (error) {
      console.error('加载列表配置失败:', error)
    }
  }
}))
```

## 📊 预期效果

### 功能效果

1. **统一数据展示**：所有模块数据通过卡片系统统一展示
2. **配置化列表**：用户可以通过配置界面自定义列表展示方式
3. **无缝详情跳转**：卡片可以无缝跳转到对应的详情页面
4. **动态字段支持**：支持所有模块字段类型的动态渲染

### 开发效果

1. **开发效率提升**：新增模块无需开发新的卡片组件
2. **维护成本降低**：统一的卡片系统减少维护成本
3. **用户体验一致**：所有模块的交互体验保持一致
4. **扩展性增强**：支持未来更多模块类型的接入

### 技术效果

1. **架构清晰**：模块系统与卡片系统职责分离
2. **代码复用**：大量组件和逻辑可以复用
3. **性能优化**：统一的数据加载和缓存策略
4. **类型安全**：完整的 TypeScript 类型支持

## 🚀 总结

这个卡片系统与模块对接方案具有以下特点：

### ✅ 核心优势

1. **Manifest 契约驱动**：基于统一的 Manifest 契约自动生成卡片配置
2. **配置化绑定**：通过 AdapterConfig 支持用户自定义列表和详情页配置
3. **动态渲染**：根据字段类型和视图配置动态渲染不同的卡片组件
4. **无缝集成**：与现有卡片系统完美集成
5. **性能优化**：通过索引提示和物化配置实现声明式性能优化

### 🎯 实施价值

1. **快速接入**：新模块可以快速接入卡片系统，无需修改前端代码
2. **用户友好**：提供直观的配置界面和统一的交互体验
3. **开发高效**：减少重复开发工作，提高开发效率
4. **扩展性强**：支持未来更多功能扩展和 AI 集成
5. **安全可靠**：字段级权限控制和数据安全裁剪

### 🔮 未来展望

1. **AI 增强**：集成 AI 能力，自动推荐最佳卡片配置和样式
2. **可视化配置**：提供拖拽式的配置界面，降低配置门槛
3. **模板系统**：提供丰富的卡片模板和主题样式
4. **性能优化**：持续优化大数据量的渲染性能和查询效率
5. **实时协作**：支持多用户实时协作编辑和配置

### 🎯 架构优化总结

通过实施上述优化方案，AINO-app 将成为一个真正的"配置即应用"平台，其中：

- **Manifest（契约）**：建立前后端统一的数据契约，消除耦合
- **查询协议（语言）**：提供标准化的数据访问接口，支持复杂查询
- **卡片容器/适配器（装配线）**：实现组件化的数据展示，支持动态配置
- **权限裁剪（安全）**：确保数据安全访问，支持字段级权限控制
- **索引/物化（性能）**：保证系统高性能运行，支持声明式优化

这个方案为 AINO 平台提供了强大的模块数据展示能力，能够满足各种复杂的业务场景需求，同时保持系统的稳定性和可维护性。通过 Manifest 契约、统一查询协议、卡片容器系统等核心组件，实现了真正的"配置即应用"，为未来的 AI 集成和自动化配置奠定了坚实基础。
